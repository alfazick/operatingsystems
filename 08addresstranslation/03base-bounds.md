# Dynamic Relocation: Base and Bounds - A Hardware Memory Management Solution

## Introduction
The first time-sharing machines of the late 1950s needed a way to:
- Run multiple programs in memory
- Protect programs from each other
- Relocate programs efficiently

The solution? Base and bounds registers in hardware.

## Dynamic Relocation: How It Works

1. **Program Creation**
   - Programs are written and compiled as if they will be loaded at address zero
   - This is the key starting point

2. **OS Loading Decision**
   - When program starts running, OS decides where in physical memory it should be loaded
   - OS sets the base register to that value
   - Example: OS loads process at 32KB, sets base register to 32KB

3. **Runtime Translation**
   - Every memory reference generated by the process is a virtual address
   - Hardware adds the contents of base register to this address
   - Result is physical address issued to memory system

## Implementation

```rust
/// Memory Management Unit (MMU) with base and bounds registers
struct MMU {
    base_register: usize,    // Starting physical memory location
    bounds_register: usize,  // Physical memory limit
}

impl MMU {
    /// Create new MMU with base and bounds
    fn new(base: usize, bounds: usize) -> Self {
        MMU {
            base_register: base,    // e.g., 32KB (where process starts)
            bounds_register: bounds, // e.g., 48KB (where process must end)
        }
    }

    /// Translate virtual to physical address with protection
    fn translate_address(&self, virtual_addr: usize) -> Result<usize, &'static str> {
        let physical_addr = virtual_addr + self.base_register;
        
        // Check if physical address within bounds
        if physical_addr < self.base_register || physical_addr >= self.bounds_register {
            return Err("Memory access violation: address out of bounds");
        }

        Ok(physical_addr)
    }
}

fn main() {
    // Process starts at 32KB and must end before 48KB (16KB size)
    let mmu = MMU::new(32 * 1024, 48 * 1024);
    
    println!("Base and Bounds Examples:\n");

    // 1. Legal instruction fetch (128 -> 32KB + 128)
    println!("1. Program fetches instruction at virtual address 128");
    match mmu.translate_address(128) {
        Ok(phys_addr) => println!("   Success: Translated to physical address {}\n", phys_addr),
        Err(e) => println!("   Failed: {}\n", e)
    }

    // 2. Legal data access (15KB -> 47KB)
    println!("2. Program accesses data at virtual address 15KB");
    match mmu.translate_address(15 * 1024) {
        Ok(phys_addr) => println!("   Success: Translated to physical address {}\n", phys_addr),
        Err(e) => println!("   Failed: {}\n", e)
    }

    // 3. Illegal access (17KB -> 49KB, beyond bounds)
    println!("3. Program attempts access at virtual address 17KB");
    match mmu.translate_address(17 * 1024) {
        Ok(phys_addr) => println!("   Success: Translated to physical address {}", phys_addr),
        Err(e) => println!("   Failed: {}", e)
    }
}
```

## Example Trace
For instruction: `128: movl 0x0(%ebx), %eax`

1. **Instruction Fetch**
   - PC = 128 (virtual)
   - Hardware adds base (32KB)
   - Fetches from physical address 32896

2. **Data Access**
   - Process issues load from virtual address 15KB
   - Hardware adds base (32KB)
   - Final physical address is 47KB

## Hardware Components

### 1. Base Register
- Contains physical start address (e.g., 32KB)
- Added to every memory reference

### 2. Bounds Register
- Contains physical end address (e.g., 48KB)
- Used for memory protection

### 3. Address Translation
For EVERY memory access:
1. Add base to virtual address:
   ```
   physical_address = virtual_address + base_register
   ```
2. Check if result is within bounds:
   ```
   base_register â‰¤ physical_address < bounds_register
   ```


### Dynamic Relocation (Hardware Solution)
- Programs compiled for address zero
- Hardware performs address translation
- Protection through bounds checking
- No program modification needed

## Key Points

1. **Hardware Protection**
   - Every memory access checked
   - Hardware enforces bounds
   - Program can't bypass checks

2. **Transparent Translation**
   - Programs write addresses as if starting at 0
   - Hardware handles translation
   - Protection is automatic

The base and bounds approach provided the first efficient hardware solution for memory protection and relocation, laying groundwork for modern virtual memory systems.
